<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Java容器基础]]></title>
      <url>http://www.xinyoushanhai.com/2017/02/16/Java%E5%AE%B9%E5%99%A8/</url>
      <content type="text"><![CDATA[1. 基本概念1.1 Java容器分类： Collection Map Collection: List：必须按照插入的顺序保存元素 Set：不能有重复的元素 Queue：按照排队规则确定对象产生的顺序（通常与他们被插入的顺序相同） Map:也被称为“关联数组”，或者“字典”。 1.2 添加元素Arrays.asList(): 接受一个数组或者一个用逗号分隔的元素列表（使用可变参数），并将其转化为一个List对象。 Collections.addAll()：接受一个Collection对象，以及一个数组或者是用一个逗号分隔的列表，将元素添加到Collection中。 1.3 List ArrayList: 优点—随机访问元素；缺点—但是在List中间插入和移除元素时比较慢。 LinkedList: 优点—在List中间进行插入和删除操作代价低，提供了优化的顺序访问；缺点—随机访问相对比较慢，但是特性集较ArrayList更大。 contains() ：确认某个对象是否在列表中，依赖equals()方法。 remove() ：移除一个对象，则可以将这个对象的引用传递给remove()方法，依赖equals()方法。也可以直接传递索引值移除对象，不依赖equals()方法。 indexOf() ：查询对象在List中所处位置的索引编号，将该对象传递给indexOf()方法，依赖equals()方法。 subList() ：允许你从较大的列表中创建出一个片段，而将其结果传递给这个较大列表的containsAll()方法时，很自然得到true。 retainAll() ：求交集，依赖equals()方法。 removeAll() ：从List中移除在参数List中的所有元素，依赖equals()方法。 set() ：在指定的索引处（第一个参数），用指定的参数替换整个位置的元素。 isEmpty() ：是否为空。 clear() ：清空列表。 Collection.toArray(new T[0]) ：List转为数组，如果参数数组太小，toArray()方法将创建一个具有合适尺寸的数组。 1.4 迭代器1.4.1 IteratorJava的Iterator只能单向移动，这个Iterator只能用来： 使用方法iterator()要求容器返回一个Iterator。Iterator将准备好返回序列的第一个元素。 使用next()获得序列中的下一个元素。 使用hasNext()检查序列中是否还有元素。 使用remove()将迭代器新近返回的元素删除。 1.4.2 ListIteratorListIterator是Iterator的子类，只能用于各种List类的访问，可以双向移动。 12345678910111213141516171819202122public class OtherTest &#123; @Test public void test() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList("hello", "world", "happy")); //指向List开始处的位置 ListIterator&lt;String&gt; iterator = list.listIterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next() + ", " + iterator.nextIndex() + ", " + iterator.previousIndex()); &#125; while (iterator.hasPrevious())&#123; System.out.println(iterator.previous() + ", " + iterator.previousIndex() + ", " + iterator.nextIndex()); &#125; //指向List索引为2的元素处 iterator = list.listIterator(2); while (iterator.hasPrevious())&#123; System.out.println(iterator.previous()); iterator.set("Good"); &#125; System.out.println(list); &#125;&#125; 1.5 LinkedListLinkedList 在List中间插入和移除时比ArrayList更高效，但在随机访问操作方面却要逊色一些。它还添加了可以使其用作栈，队列或双端队列的方法。 getFirst()和element()：都返回列表的头（第一个元素），而不移除它，如果List为空，则抛出NoSuchElementException。 peek()：在列表为空时返回null。 removeFirst()与remove()：移除并返回列表的头，在列表为空时抛出NoSuchElementException。 poll()：列表为空时返回null。 addFirst()和add()以及addLast()：将某个元素插入到列表的尾（端）部。 removeLast()：移除并返回列表的最后一个元素。 LinkedList 可以当做栈来使用。 1.6 SetSet不保存重复的元素。HashSet提供最快的查询速度；TreeSet保持元素处于排序状态；LinkedHashSet以插入顺序保存元素。 1.7 MapHashMap设计用来快速访问；TreeMap保持“键”始终处于排序状态，所以没有HashMap快。LinkedHashMap保持元素插入的顺序，但是也通过散列提供了快速访问能力。 1.8 Queue队列是一个典型的先进先出（FIFO）的容器。LinkedList可以用作Queue的一种实现。 1234567891011public class OtherTest &#123; @Test public void test() &#123; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); Random random = new Random(47); for (int i = 0; i &lt; 10; i++) &#123; queue.offer(random.nextInt(i+10)); &#125; System.out.println(queue); &#125;&#125; 1.9 PriorityQueue优先队列声明下一个弹出元素是最需要的元素（具有最高的优先级）。当你在PriorityQueue上调用offer()方法来插入一个对象时，这个对象会在队列中被排序。默认的排序将使用对象在队列中的自然排序。 123456789101112public class OtherTest &#123; @Test public void test() &#123; String fact = "EDASASAD SDSADD QWACASASV"; List&lt;String&gt; list = Arrays.asList(fact.split(" ")); PriorityQueue&lt;String&gt; priorityQueue = new PriorityQueue&lt;&gt;(list); System.out.println(priorityQueue); priorityQueue = new PriorityQueue&lt;&gt;(list.size(), Collections.reverseOrder()); priorityQueue.addAll(list); System.out.println(priorityQueue); &#125;&#125; 2.0 适配器方法惯用法123456789101112131415161718192021222324252627282930313233343536373839404142public class OtherTest&lt;T&gt; extends ArrayList&lt;T&gt; &#123; public OtherTest(Collection&lt;T&gt; c) &#123; super(c); &#125; public Iterable&lt;T&gt; reversed() &#123; return new Iterable&lt;T&gt;() &#123; @Override public Iterator&lt;T&gt; iterator() &#123; return new Iterator&lt;T&gt;() &#123; int current = size() - 1; @Override public boolean hasNext() &#123; return current &gt; -1; &#125; @Override public T next() &#123; return get(current--); &#125; @Override public void remove() &#123; throw new UnsupportedOperationException(); &#125; &#125;; &#125; &#125;; &#125; public static void main(String[] args) &#123; OtherTest&lt;String&gt; otherTest = new OtherTest&lt;&gt;(Arrays.asList("To be or not to be".split(" "))); for (String s : otherTest) &#123; System.out.print(s + " "); &#125; for (String s : otherTest.reversed()) &#123; System.out.print(s + " "); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[The IoC container 7.3~7.4]]></title>
      <url>http://www.xinyoushanhai.com/2017/02/14/The-IoC-container-1/</url>
      <content type="text"><![CDATA[7.3 Bean overviewSpring IoC容器管理一个或多个bean。这些bean根据你提提供给容器的配置元数据创建，比如，在XML &lt;bean/&gt; 定义组成中。 在容器内部，这些bean定义表示为 BeanDefinition 对象，含有（其他信息）一下元数据： 限定包类名称：通常是定义的bean的实现类 bean的行为配置元素，在容器中bean的作用阶段（范围，生命周期回调等等） 引用其他的必须的bean来为此bean完成工作；这些引用也被称为协作或者依赖关系 其他配置设置来创建新的对象，例如，在一个bean中使用连接数量，用来管理连接池或者限制连接池的大小。 这些元数据转换成一组属性，组成每一个bean定义。 除了bean定义包含如何创建一个特定bean的信息，ApplicationContext 实现还允许用户注册容器之外的现有对象。这是通过访问ApplicationContext的BeanFactory中的方法 getBeanFactory ，返回BeanFactory的实现类 DefaultListableBeanFactory。DefaultListableBeanFactory 通过方法 registerSingleton(..) 和 registerBeanDefinition(..) 支持注册。然而，典型的应用只能通过元数据定义的bean工、运作。 7.3.1 Naming beans每个bean都有一个或多个标识符。这些标识符必须在托管的容器中唯一。bean通常只有一个标识符，但是它需要不止一个，可以考虑额外的别名。 在基于XML配置的元数据中，你可以使用id 或者 name 属性指定bean的标识符。id 属性允许你指定一个id。通常这些名字是字母数字，但是也可能包含特殊字符。如果你想引进其他别名到你的bean中，你还可以在name属性中指定他们，由逗号（,），分号（,）或者空白分隔开。 你不需要为一个bean提供name或者id。如果没有显示的提供name或者id，容器会为这个bean生成一个唯一的名称。然而，你想通过 ref元素或者本地服务发现，使用name引用一个bean，你必须为bean提供一个name。 Aliasing a bean outside the bean definition在bean定义中，你可以提供多个name，通过结合使用id 属性指定的一个名字，和由name属性提供的任意数量其它名字。这些名字对于同一个bean是等价的别名，并且在一些场景中是有用的，比如允许应用中的每一个组件，使用在其内部指定的bean名称来引用同一个依赖。 然而，在bean被创建的时候指定所有别名总是不恰当的。有时候需要为bean在它被定义的地方引进一个别名。这种情况通常出现在大型系统中，那些配置被分割在每个子系统中的地方，每个子系统都有自己的一组对象定义。在基于XML配置的元数据中，你可以使用&lt;alias/&gt; 元素来完成这项工作。 1&lt;alias name="fromName" alias="toName"/&gt; 在这种情况下，在相同的容器中，一个bean被命名为forName ，也可能，使用别名定以后，通过别名toName被引用。 例如，子系统A的配置元数据可能通过名称subsystemA-dataSource 引用一个数据源。子系统B的配置元数据可能通过名称subsystemB-dataSource引用t同一个数据源。当使用这个两个系统组成的主应用中，通过使用名称myApp-dataSource 引用同一个数据源。对同一个对象的引用有三个名称，添加下面的别名配置到MyApp配置元数据中。 12&lt;alias name="subsystemA-dataSource" alias="subsystemB-dataSource"/&gt;&lt;alias name="subsystemA-dataSource" alias="myApp-dataSource" /&gt; 现在每一个组件和主应用都可以通过唯一的一个名称引用数据源，来保证不与其他任何定义冲突（有效的创建一个命名空间），而且他们引用的是同一个bean。 7.3.2 Instantiating beans一个bean的定义实质上是创建一个或多个对象的方式。当一个bean被调用时，容器来查询被命名的bean，并使用通过bean定义封装的配置元数据，创建一个实际的对象。 如果你使用基于XML的配置元数据，在&lt;bean/&gt;元素里的class属性指定对象的类型来实例化对象。class 属性，内部是BeanDefinition 实例的 Class 属性，通常是托管的。你可以以两种方式中的一种使用Class 属性： 通常，]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[The IoC container 7.1~7.2]]></title>
      <url>http://www.xinyoushanhai.com/2017/02/09/The-IoC-container/</url>
      <content type="text"><![CDATA[7.1 Introduction to the Spring IoC container and beans本章涵盖了Spring框架控制反转实现的原则。IoC 也被称为依赖注入（DI）。这是一个定义它们依赖关系的过程，也就是说，它们使用其它的对象，只能通过构造函数，传参到工厂方法，或者给构造器生成的对象实例或者从工厂方法返回的对象实例设置属性。然后容器创建bean时注入这些依赖。这个过程从根本上时反转，因此命名为控制反转（IoC），通过自身控制实例化或者通过构造器定位依赖关系，或者使用一种机制，如服务定位器模式。 org.springframework.beans 和 org.springframework.context 包是Spring框架IoC容器的基础。BeanFactory 接口提供了一种能够控制任何类型对象的先进的配置机制。ApplicationContext 是 BeanFactory 的子接口。它更加容易集成Spring AOP的功能；信息资源处理（用于国际化），事件发布；和应用层特定上下文如用于web应用的 WebApplicationContext 。 简而言之，BeanFactory 提供了框架的配置和基本功能，而 ApplicationContext 增加了更多的企业级特定功能。ApplicationContext 是 BeanFactory 的一个完整超集，专门用于本章描述Spring 的IoC容器。 在Spring中，组成应用骨干的对象和由Spring容器管理的对象，被称作bean。bean是一个被实例化，组装继而被Spring IoC容器管理的对象。然而，一个bean仅仅是应用中许多简单对象之一。Bean，以及它们之间的依赖关系，映射在容器中的配置元数据。 7.2 Container overvieworg.springframework.context.ApplicationContext 接口代表了Spring IoC容器，负责上述bean的实例化，配置和组装。容器通过读取配置元数据。配置元数据使用XML，Java注解，或Java代码。它明确了你应用中的对象和这些对象之间的依赖关系。 Spring中几个 ApplicationContext 接口的实现开箱即用。在独立的应用中，通常创建一个 ClassPathXmlApplicationContext 或者 FileSystemXmlApplicationContext 的实例。在定义配置元数据时，尽管XML是一种传统的格式，你依然可以使用Java注解或者代码作为元数据格式，这样可以提供少量的XML配置，声明能够支持这些额外的元数据格式。 在大多数的应用场景中，Spring IoC 容器中实例化一个或多个实例，明确用户代码是非必须的。例如，在web应用场景中，一个有简单的八行（左右）样板web XML描述代码的 web.xml 文件的应用通常就足够了。 下图是一个Spring如何工作的高级视图。在 ApplicaitonContext 被创建和实例化后，你的应用类会和配置元数据捆绑，这样你就会有一个完全配置过的和可执行的系统或应用。 7.2.1 Configuration metadata如前图所示，Spring IoC容器消费配置元数据，应用开发人员在开发应用时，使用配置元数据告诉Spring容器如何初始化、配置和组装对象。 配置元数据通常使用一种简单直观的XML格式，这种格式大多数章节要使用到，来展示Spring IoC容器的关键概念和功能。 想要在Spring容器中使用其它形式的元数据信息，请看： 基于注解的配置 基于Java代码的配置：从Spring 3.0开始，Spring JavaConfig项目提供了许多特性，并成为了Spring框架核心的一部分。因此你不仅仅使用XML文件定义bean，还可以使用JavaConfig定义。为了使用这些新特性，请查看 @Configuration ，@Bean ,@Bean ,@Import ,和 @DependsOn 注解。 Spring配置包含至少一个或者多个典型的bean定义，以便容器管理。基于XML的配置元数据使用一个包含在顶级元素 &lt;beans/&gt; 里面的 &lt;bean/&gt; 元素显示的。Java配置通常 @Bean 注解方法与 @Configuration 注解一起使用。 这些bean定义对应于组成你应用的实际对象。通常你会定义service层对象，数据访问对象（DAOs），表示层对象如Struts Action 实例，基础架构对象如Hibernate SessionFactories ，JMS Queues 等等。通常在容器中不配置细粒度的域对象，因为这通常是DAOs的任务，由业务逻辑创建和加载域对象。但是，你可以使用Spring与AspectJ的集成来配置那些在IoC容器之外被创建的对象。 下面的例子展示了基于XML配置的配置元数据的基本结构： 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="..." class="..."&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;bean id="..." class="..."&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;!-- more bean definitions go here --&gt;&lt;/beans&gt; id属性是一个字符串，用于识别单个bean定义。class属性定义bean的类型，使用完全限定类名。id属性的值指的是协作对象。 7.2.2 Instantiating a container实例化一个Spring IoC容器是很简单的。提供给 ApplicationContext 构造器的位置路径或者其它路径，实际上是资源字符串，使得容器从各种各样的外包资源，如本地文件系统，从Java CLASSPATH 等等，加载配置元数据。 12ApplicationContext context = new ClassPathXmlApplicationContext(new String[] &#123;"services.xml", "daos.xml"&#125;); 下面的例子服务层对象（service.xml）配置文件： 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- services --&gt; &lt;bean id="petStore" class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl"&gt; &lt;property name="accountDao" ref="accountDao"/&gt; &lt;property name="itemDao" ref="itemDao"/&gt; &lt;!-- additional collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;!-- more bean definitions for services go here --&gt;&lt;/beans&gt; 下面的例子展示了数据访问层对象 daos.xml 文件： 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="accountDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao"&gt; &lt;!-- additional collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;bean id="itemDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaItemDao"&gt; &lt;!-- additional collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;!-- more bean definitions for data access objects go here --&gt;&lt;/beans&gt; 在上面的例子中，服务层包括类 PetStoreServiceImpl ，和两个数据访问层对象 JapAccountDao 和 JpaItemDao （基于JPA对象/关系映射的标准）。property name 元素指的是JavaBean属性的名称，ref 元素指的是另一个bean定义的名称。id 和 ref 元素之间的联系表达了合作对象之间的依赖关系。 Composing XML-based configuration metadata这对于XML文件定义多个bean是有用的。在你的体系结构中，通常每个单独的XML配置文件代表了一个逻辑层或者模块。 你可以使用应用上下文构造器从所有这些SML片段中加载bean的定义。这个构造器使用了多个 Resource 定位资源，就像上一节所示。或者，使用一个或多个 &lt;import/&gt; 元素指引从其它文件加载bean的定义。例如： 12345678&lt;beans&gt; &lt;import resource="services.xml"/&gt; &lt;import resource="resources/messageSource.xml"/&gt; &lt;import resource="/resources/themeSource.xml"/&gt; &lt;bean id="bean1" class="..."/&gt; &lt;bean id="bean2" class="..."/&gt;&lt;/beans&gt; 在前面的例子中，从三个文件加载外部bean定义：services.xml , messageSource.xml , 和 themeSource.xml 。所有的位置路径是相对于要导进的定义文件，所以 services.xml 必须与要导进的文件位于同一个目录或者类路径下面，而 messageSource.xml 和 themeSource.xml 必须位于 resources 位置下，低于要导进的文件位置。正如你所看到的，开头的正斜杠是被忽略掉的，但是考虑到这些路径是相对的，最好不要使用开头的这个斜杠。被导入的文件内容，包括顶级的 &lt;beans/&gt; 元素，必须是根据Spring Schema定义得有效的XML bean。 导入指令是由bean本身的命名空间提供的功能。比普通的bean定义进一步的配置功能，在Spring提供的XML 命名空间选择上，如“context”和“util”命名空间。 7.2.3 Using the containerApplicationContext 是一个能够注册不同bean及其依赖的高级工厂接口。使用方法 T getBean(String name,Class&lt;T&gt; requiredType) 你可以取回bean的实例。 ApplicationContext 使你能够读取bean定义并访问它们，像下面这样： 12345678// create and configure beansApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");// retrieve configured instancePetStoreService service = context.getBean("petStore", PetStoreService.class);// use configured instanceList&lt;String&gt; userList = service.getUsernameList(); 然后你可以使用 getBean 获取bean的实例。ApplicationContext 接口有一些其它的方法获取bean，但是理想情况下你的应用代码不应该使用它们。事实上，你的应用代码根本就不该调用 getBean() 方法，从而不依赖Spring的APIs。例如，整合web框架的Spring为各种各样的框架组件如controller和JSF管理bean提供了依赖注入，允许你通过元数据在特定的bean上声明依赖（如自动装配注解）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Overview of Spring Framework]]></title>
      <url>http://www.xinyoushanhai.com/2017/02/08/Overview-of-Spring-Framework/</url>
      <content type="text"><![CDATA[Overview of Spring FrameworkSpring框架是一个轻量级的解决方案和一个潜在的一站式服务框架，用以构建企业级应用。然而，Spring是模块化的，它允许你使用你需要的那部分，不必引进其他部分。你可以在任何web框架上使用IOC容器，但你也可以只使用Hibernate集成代码或者JDBC抽象层。Spring框架支持声明式的事务管理，通过RMI或者web服务远程访问你的业务，和各种选择来持久化你的数据。它提供了一个功能齐全的MVC框架，允许你将AOP透明地整合到你的软件。 Spring被设计为非侵入性的，这意味着你的本地业务代码通常没有依赖框架本身。在集成层（比如数据访问层），Spring库中存在一些依赖于数据访问的技术。所以，它容易从你的本地代码隔离出这些依赖项。 这篇文档是Spring框架功能的参考指南。 1 Getting Started with Spring这篇参考指南提供了Spring框架的详细信息。它为所有功能提供了全面的文档，以及Spring拥有的一些基础概念（比如依赖注入）的背景。如果你是刚开始学习Spring，你可能需要通过创建一个Spring Boot应用来使用Spring框架。Spring Boot提供了一种快速的方式来创建一个可以发布生产环境的基于Spring的应用。它基于Spring框架，支持约定优于配置，目的是让你尽快拉起并启动应用。 2 Introduction to the Spring FrameworkSpring框架是一个基于Java平台下，提供全面的基础架构来支持开发Java应用。Spring处理基础架构，这样你就可以专注自己的应用了。Spring让你能够使用从普通旧式的Java对象到POJOS非入侵式地构建应用和提供企业级的服务。此功能适用于Java SE全部和部分Java EE编程模型。 比如，作为应用程序开发者，可以受益于Spring平台： 无需处理事务API，使Java方法执行数据库事务。 无需处理远程API，使本地Java方法远程化。 无需处理JMX API，使本地Java方法管理操作化。 无需处理JMS API，使本地Java方法消息处理化。 2.1 Dependency Injection and Inversion of ControlJava应用–一个松散的术语，从受限的嵌入式应用到n层、服务器段企业级应用–通常由多个对象适当的组合成应用。因此，对象在应用程序中相互依赖。 尽管Java平台提供了丰富的应用开发功能，但它缺少基本构建块组织成一个连贯整体的方法，这个任务遗留给了架构师和开发人员。虽然可以使用设计模式，例如工厂模式，抽象工厂模式，建筑模式，装饰模式和服务定位器构成的各种类和对象实例，来构建应用，这些模式是：模式的名字是最佳实践给出的，这些模式是做什么的，如何应用它，它解决的问题，等等。模式是有效的最佳实践，你必须在自己的应用中实现它。 Spring框架的控制反转（IOC）组件处理了这种问题，通过一种有效的方法，组成不相干的组件，在一个运行着的应用中很好地使。Spring框架将设计模式作为优先的对象，你可以集成到你自己的应用程序中。众多组织和机构按照这种方式使用Spring框架，设计健壮的，可维护的应用。 2.2 ModulesSpring框架包含的功能划分为大约20个模块。这些模块被分为核心容器，数据访问层/集成，Web层，AOP（面向方面的变成），机制，消息，和测试，如下列图所示。 2.2.1 Core ContainerSpring核心容器包含 spring-core,spring-beans,spring-context,spring-context-support ,和 spring-expression 模块。 spring-core 和 spring-beans 模块提供了框架的基本部分，包括IOC和依赖注入。 BeanFactory 是一个复杂的工厂模式实现。塔消除了程序单例化的需求，并允许你解耦配置和规范依赖从你的实际程序逻辑中。 上下文（spring-context）模块建立在Core和Beans模块提供的坚实基础上：它意味着需要按照一种框架样式的方式访问对象，类似与一个JNDI注册表。上下文模块（Context）从Beans模块继承它的功能，并增加了对国际化（例如，使用资源包），事件传播，资源加载以及直接通过Servlet容器创建上下文的支持。上下文（Context）模块还支持Java EE 的特性，比如EJB，JMX，和基本的远程控制。 ApplicationContext 接口是Context模块的焦点所在。 spring-context-support 支持将常见的第三方库集成到Spring的上下文中，如缓存（EhCache,Guava,JCache）,邮件（JavaMail），调度（CommonJ,Quartz）以及模板引擎（FreeMarker,JasperReports,Velocity）。 spring-expression 模块提供了一个强大的表达式语言，再运行时查询和操作一个对象图。这是一个基于JSP 2.1规范中进行的统一表达式语言的扩展。这种语言支持属性的设置与获取值，属性的设置，方法的调用，数组内容的访问，集合和索引，逻辑和算术运算符，变量命名和从Spring IOC容器中根据名称检索对象。它还支持列表的投影，选择以及常见的列表聚合。 2.2.2 AOP and Instrumentationspring-aop 模块提供了一个AOP，允许你定义面向方面的编程实现，例如，方法拦截器和切入点可以解耦那些应该被分离开的实现了功能性的代码。使用源代码级的元数据功能，你还可以将行为信息合并到你的代码中，在某种程度上，与.NET属性类似。 单独的 spring-aspects模块提供了与AspectJ集成。 spring-instrument 模块提供了用于某些应用服务器中类机制的支持和类加载器的实现。 spring-instrument-tomcat 模块为Tomcat包含了Spring机制代理。 2.2.3 MessagingSpring框架4中包含 spring-messaging 模块，使用来自Spring集成的项目如 Message ,MessageChannel,MessageHandler,和其他的关键抽象类，作为基于消息传递的应用程序的基础。此模块还包含一组消息映射到方法的注解，类似基于变成模型的Spring MVC注解。 2.2.4 Data Access/Integration数据访问/集成层包含JDBC，ORM，ORM，OXM，JMS，和事务模块。 spring-jdbc 模块提供了一个JDBC抽象层，消除了需要做乏味的JDBC编码和数据库供应商的错误编码和解析。 spring-tx 模块支持对于实现了专用接口和所有的POJO（传统的普通Java对象）类，提供编程和声明式事务管理。 spring-orm 模块提供了流行的对象-关系映射集成层API，包括JPA，JDO，和Hibernate。使用 spring-orm 模块后，你可以结合Spring提供的所有其他特性，使用O/R映射集合框架，例如前面提到的简单的声明式事务管理功能。 spring-oxm 模块提供了一个抽象层，支持Object/XML映射的实现，如JAXB，Castor，XML Beans，JiBX和XStream。 spring-jms 模块包含产生和消费消息的功能。由于Spring框架4.1提供了与 spring-messaging 模块的集成。 2.2.5 WebWeb层包括 spring-web, spring-webmvc ,spring-websocket ,和 spring-webmvc-portlet 模块。 spring-web 模块提供了基本的面向web的集成特性，比如分部分的文件上传功能和使用Servlet监听器初始化IOC容器，以及一个面向web应用的上下文。它还包含一个HTTP客户端和基于Spring的远程支持的web相关部分。 spring-webmvc 模块（也被称为Web-Servlet模块）包含Spring的模型-视图-控制器（MVC）和REST Web服务实现的Web应用。Spring的MVC框架提供了在域模块代码与web表单之间干净的分离，并集成了所有Spring框架的其他特性。 spring-webmvc-portlet 模块（也被称为Web-Portlet模块）提供了MVC的实现，用于 spring-webmvc 功能模块的Portlet环境中。 2.2.6 Testspring-test 模块提供了单元测试，集成Junit或者TestNG到Spring组件测试中。它提供了Spring ApplicationContext 一致性加载以及这些上下文的缓存。它还提供了模拟对象，你可以以隔离的方式测试你的代码。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017计划白皮书]]></title>
      <url>http://www.xinyoushanhai.com/2017/01/06/2017%E8%AE%A1%E5%88%92%E7%99%BD%E7%9A%AE%E4%B9%A6/</url>
      <content type="text"><![CDATA[一、计划看的书籍《java编程思想》三个月内看完 《数据结构与算法分析：Java语言描述》三个月看完+LeetCode刷题 《深入理解计算机系统》 《大话设计模式》 《深入理解Java虚拟机》 《重构》 《Java并发编程》 二、文档Dubbo 文档 spring文档 shiro文档 mybatis文档 三、源码学习Dubbo源码 spring部分源码 shiro源码 mybatis源码 四、要深入学习的java多线程、IO/NIO、容器、注解、序列化、泛型 五、要学会熟练使用的并了解其基本原理kafka es activeMQ redis nginx 六、需要了解的java8相关特性 七、做开源的项目多做几个轮子 八、今年三月份做完自己的项目并上线加紧业务逻辑的代码编写，保证基本服务正常运行，上线 之后进行业务拆分，做一个详细的业务系统规划]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Down By the Salley Garden]]></title>
      <url>http://www.xinyoushanhai.com/2016/10/20/Down-By-the-Salley-Garden/</url>
      <content type="text"><![CDATA[Down by the Salley Gardens，My love and I did meet.She passed the salley gardens with little snow-white feet.She bid me take love easy, as the leaves grow on the tree;But I, being young and foolish, with her would not agree.In a field by the river my love and I did stand,And on my leaning shoulder she laid her snow-white hand.She bid me take life easy, as the grass grows on the weirs;But I was young and foolish, and now am full of tears.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[心有山海，静而无边]]></title>
      <url>http://www.xinyoushanhai.com/2016/10/20/%E5%BF%83%E6%9C%89%E5%B1%B1%E6%B5%B7%EF%BC%8C%E9%9D%99%E8%80%8C%E6%97%A0%E8%BE%B9/</url>
      <content type="text"><![CDATA[He Wishes for the Cloths of HeavenHad I the heaven’s embroidered cloths,Enwrought with golden and silver light,The blue and the dim and the dark cloths,Of night and light and the half-light,I would spread the cloths under your feet,But I, being poor, have only my dreams,I have spread my dreams under your feet,Tread softly because you tread on my dreams.]]></content>
    </entry>

    
  
  
</search>
